#-*- coding:utf-8 -*-
class Cidr:
    def __init__(self, ips):
        self.ips = ips

    def bin2ip(self, b):
        ip = ""
        for i in range(0, len(b), 8):
            ip += str(int(b[i:i + 8], 2)) + "."
        return ip[:-1]

    # convert a decimal number to binary representation
    # if d is specified, left-pad the binary number with 0s to that length
    def dec2bin(self, n, d=None):
        s = ""
        while n > 0:
            if n & 1:
                s = "1" + s
            else:
                s = "0" + s
            n >>= 1
        if d is not None:
            while len(s) < d:
                s = "0" + s
        if s == "": s = "0"
        return s

    # convert an IP address from its dotted-quad format to its
    # 32 binary digit representation
    def ip2bin(self, ip):
        b = ""
        inQuads = ip.split(".")
        outQuads = 4
        for q in inQuads:
            if q != "":
                b += self.dec2bin(int(q), 8)
                outQuads -= 1
        while outQuads > 0:
            b += "00000000"
            outQuads -= 1
        return b

    def listCIDR(self):
        cidrlist = []
        parts = self.ips.split("/")
        baseIP = self.ip2bin(parts[0])
        subnet = int(parts[1])
        # Python string-slicing weirdness:
        # "myString"[:-1] -> "myStrin" but "myString"[:0] -> ""
        # if a subnet of 32 was specified simply print the single IP
        if subnet == 32:
            print(self.bin2ip(baseIP))
        # for any other size subnet, print a list of IP addresses by concatenating
        # the prefix with each of the suffixes in the subnet
        else:
            ipPrefix = baseIP[:-(32 - subnet)]
            for i in range(2 ** (32 - subnet)):
                cidrlist.append(self.bin2ip(ipPrefix + self.dec2bin(i, (32 - subnet))))
            return cidrlist

# print(CIDR('142.14.72.24/18').listCIDR())