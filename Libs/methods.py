#-*- coding:utf-8 -*-
from Libs.glo import *
logger = get_value('logger')

def IptoNum(Host):
    splitHostList = [int(hostIp) for hostIp in Host.split('.')]             #splitHostList为IP分割后的IP列表
    HostNum = sum([splitHostList[i] << [24,16,8,0][i] for i in range(4)])   #HostNum位IP转为为10进制后的结果
    return HostNum

def NumtoIp(HostNum):
    HostIp = '.'.join([str(HostNum >> j & 0xff) for j in [24,16,8,0]])      # &按位与
    return HostIp

# 解析IP
def ipParse():
    ips = get_value('ips')
    from Libs.CIDR import Cidr

    logger = get_value('logger')
    q_ip = getQueue()  # 存放IP队列

    ip_list = []
    if '/' in ips:
        ip_list = Cidr(ips).listCIDR()

    elif '-' in ips:
        ip_start, ip_end = ips.split('-')[0], ips.split('-')[1]
        for ip_num in range(IptoNum(ip_start), IptoNum(ip_end) + 1):
            ip = NumtoIp(ip_num)
            ip_list.append(ip)
    else:
        ip_list.append(ips)

    logger.info('[Len{}] {}'.format(len(ip_list), ip_list))
    # 存入队列
    for ip in ip_list:
        q_ip.put(ip)

    set_value('q_ip', q_ip)

def filesParse():
    filesPath = get_value('filesPath')
    q_ip = getQueue()
    with open(filesPath, 'rt') as f:
        for each in f.readlines():
            q_ip.put(each.strip())
    set_value('q_ip', q_ip)


# 获取一个队列
def getQueue():
    from queue import Queue
    q = Queue(-1)
    return q

# 复制队列
def copyQueue():
    q = get_value('q_ip')
    from queue import Queue
    q2 = Queue(-1)
    L = []
    while not q.empty():
        L.append(q.get())
    for each in L:
        q.put(each)
        q2.put(each)
    return q2

# 导入pingMulThr，使用多线程ping IP
def pingThread():
    q_ip_ping = copyQueue()  # 复制队列q_ip
    threadNum = get_value('threadNum')
    from Libs.pingCls import pingMultiThr
    threads = []
    for num in range(1, threadNum+1):
        p = pingMultiThr(q_ip_ping, num)
        p.start()
        threads.append(p)
    for p in threads:
        p.join()

# 多线程扫描IP，协程扫描端口
def scanPortThread():
    ports = get_value('ports')
    q_ip_scanPort = copyQueue()  # 复制队列q_ip
    threadNum = get_value('threadNum')
    from Libs.scanPortCls import scanPortMultiThr
    threads = []
    for num in range(1, threadNum + 1):
        t = scanPortMultiThr(q_ip_scanPort, num, ports)
        t.start()
        threads.append(t)
    for t in threads:
        t.join()

# 将扫描端口结束后的IP存放到队列里  从{'123.125.115.109': ['80'], '123.125.115.110': ['80'], '123.125.115.111': ['80']}字典里获取IP
def probeServiceIpQueue():
    ipOpenPort = get_value('ipOpenPort')
    from queue import Queue
    q = Queue(-1)
    for _ in ipOpenPort.keys():
        q.put(_)
    return q

# 多线程扫描IP，协程探测服务
def probeServiceThread():
    threadNum = get_value('threadNum')
    from Libs.probeServiceCls import probeServiceMultiThr
    q = probeServiceIpQueue()
    threads = []
    for num in range(1, threadNum + 1):
        t = probeServiceMultiThr(q, num)
        t.start()
        threads.append(t)
    for t in threads:
        t.join()

# 处理端口扫描的逻辑
def portParse():
    port = get_value('port')        # port：输入的端口命令，-p all ，-p 80,81,82  , -p 1-1024
    if port == 'all':
        ports_protocols = get_value('ports_protocols')
        ports = list(ports_protocols.keys())
    elif ',' in port:
        ports = port.split(',')  # ['80', '81', '82']
    elif '-' in port:
        ports = list(
            map(lambda x: str(x), range(int(port.split('-')[0]), int(port.split('-')[1]) + 1)))  # ['80', '81', '82']
    else:
        ports = [port]

    set_value('ports', ports)       # 将端口号存入全局变量里


# 检查服务是否可被爆破，可被爆破返回服务名字和密码字典名字，不可被爆破返回None
def checkBrustService(__service):
    pwdTxtsName = get_value('pwdTxtsName')
    for pwdTxtName in pwdTxtsName:
        if __service in pwdTxtName:
            return pwdTxtName
    return None

# 打开密码本，将密码存入全局变量里
def setGloPwdContent(pwdTxtName):
    if not exist_key(pwdTxtName):
        pwdContent = []
        with open('PwdTxt/{}'.format(pwdTxtName), 'rt') as f:
            for each in f.readlines():
                pwdContent.append(each.strip())
        set_value(pwdTxtName, pwdContent)
    else:
        pass
        # logger.info('全局变量已经存在{}'.format(pwdTxtName))
# 爆破解析
def brustParse():
    serviceList = get_value('serviceList')          # {'127.0.0.1': {'80': ['http'], '3306': ['mysql']}}
    brustPortDic = get_value('brustPortDic')
    for brust_ip in serviceList:
        for _port in serviceList[brust_ip]:
            _service = serviceList[brust_ip][_port]     # _service == ['mysql', 'UnKnow']
            for __service in _service:
                pwdTxtName = checkBrustService(__service)     # __service ==  'mysql'
                # print(brust_ip, _port, __service, pwdTxtName)       # 118.99.13.58 3306 mysql dic_password_mysql.txt         118.99.13.58 3306 db2jds None
                if pwdTxtName:
                    setGloPwdContent(pwdTxtName)
                    brustPortDic[brust_ip] = {}
                    brustPortDic[brust_ip][_port] = pwdTxtName      # {'116.89.248.27': {'3306': 'dic_password_mysql.txt'}, '116.89.248.28': {'3306': 'dic_password_mysql.txt'}}
    q_brustIp = getQueue()
    for _ in brustPortDic.keys():
        q_brustIp.put(_)
    logger.info('Len[{}] Brust!'.format(q_brustIp.qsize()))
    brustPortThread(q_brustIp)
            #     q_pwd = get_value(pwdTxtName)
            #     brustPortThread(brust_ip, _port, q_pwd, __service)


# 多线程爆破端口
def brustPortThread(q_brustIp):
    from Exploit.brustPortCls import brustPortMultiThr     # 导入多线程爆破端口
    threadNum = get_value('threadNum')
    event = getThrEvent()
    threads = []
    for num in range(1, threadNum + 1):
        t = brustPortMultiThr(q_brustIp, event)
        t.start()
        threads.append(t)
    for t in threads:
        t.join()


